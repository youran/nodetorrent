const assert = require('assert');

module.exports.decode = (buf, cb) => {
		cb(null, parseBlock(buf));
};

module.exports.encode = (data, cb) => {
		cb(null, encodeData(data));
};

// Code for decoding
var calcIntBlockLength = (buf, offset) => {
	return buf.indexOf('e', offset) - offset + 1;
};

var calcStrBlockLength = (buf, offset) => {
		var colonPos = buf.indexOf(':', offset), tmpBuf;

		if (colonPos === -1) {
			return -1;
		}

		tmpBuf = buf.slice(offset, colonPos).toString();
		if (isNaN(tmpBuf) === true) {
			return -1;
		} else {
			return colonPos - offset + parseInt(tmpBuf, 10) + 1;
		}
};

var calcSingleBlockLength = (buf, offset, nestedLevel) => {
	// calculate length for the block at buf[offset]
	var char = String.fromCharCode(buf[offset]), char1 = String.fromCharCode(buf[offset + 1]);
	var element, endPos;

	if (char === 'i') {
		return calcIntBlockLength(buf, offset);
	} else if (char >= '0' && char <= '9') {
		return calcStrBlockLength(buf, offset);
	} else if (char === 'l' || char === 'd') {
		if (char1 === 'e') {
			return 2;
		}
		return calcTopBlockLengths(buf.slice(offset + 1), nestedLevel + 1) + 2; // inner blocks + beginner + terminator
	} else if (char === 'e') {
		return 0;	// terminator length already accounted
	} else {
		return -1;
	}
};

var calcTopBlockLengths = (buf, nestedLevel) => {
	// calculate all top level blocks' length
	// for use in lists and dictionaries
	var offset = 0, maxLen = Buffer.byteLength(buf);
	var lens = [];
	while (offset < maxLen) {
		let len = calcSingleBlockLength(buf, offset, nestedLevel), blockLength = 0;
		if (len === -1) {
			return -1;
		}
		if (len === 0) {
			// met the 'e' terminator for current nested level
			break;
		}
		
		blockLength = len;
		lens.push(blockLength);
		offset += blockLength;
	}

	if (nestedLevel === 0) {
		return lens;
	} else {
		let totalLen =0;
		for (let val of lens) {
			totalLen += val;
		}
		return totalLen;
	}
	
};

var parseByteString = (buf) => {
	var colonPos = buf.indexOf(':');
	var len, numStr;
	var strBegin, strEnd, result;

	if (colonPos === -1) {
		return -1;
	}

	numStr = buf.slice(0, colonPos).toString();
	if (isNaN(numStr) === true) {
		return -1;
	}

	len = parseInt(numStr, 10);
	if (len === 0) {
		return '';
	}

	strBegin = colonPos + 1;
	strEnd = strBegin + len + 1;
	result = buf.slice(strBegin, strEnd);
	return result;
};


var parseInteger = (buf) => {
	var ePos = buf.indexOf('e');
	var numStr, val;

	if (ePos === -1) {
		return -1;
	}

	numStr = buf.slice(1, ePos).toString();
	if (isNaN(numStr) === true) {
		return -1;
	}

	val = parseInt(numStr, 10);
	return val;
};

var parseList = (buf) => {
	// parse list block begining with 'l'
	var offset = 1, maxLen = Buffer.byteLength(buf);
	var listItems = [], result = [];
	var nestedLevel = 0;
	var lens = calcTopBlockLengths(buf.slice(1, maxLen - 1), nestedLevel);

	if (lens === -1) {
		return -1;
	}

	for (let len of lens) {
		listItems.push(buf.slice(offset, offset + len));
		offset += len;
	}

	assert(offset === (maxLen - 1));	// offset must at character 'e' (list terminator)

	for (let item of listItems) {
		var obj = parseBlock(item);
		if (obj === -1) {
			return -1;
		}
		result.push(obj);
	}

	return result;
};

var parseDict = (buf) => {
	// parse dictionary block begining with 'd'
	var offset = 1, maxLen = Buffer.byteLength(buf);
	var dictItems = [], result = {};
	var nestedLevel = 0;
	var lens = calcTopBlockLengths(buf.slice(1, maxLen - 1), nestedLevel);

	if (lens === -1) {
		return -1;
	}

	for (let len of lens) {
		dictItems.push(buf.slice(offset, offset + len));
		offset += len;
	}

	if ((dictItems.length % 2) !== 0) {
		// must be a multiple of 2
		return -1;
	}

	for (let i = 0; i < dictItems.length; i += 2) {
		// TODO: key type validation, and error return when parseBlock() returns -1
		var key = parseBlock(dictItems[i]).toString(), val = parseBlock(dictItems[i + 1]);
		result[key] = val;
	}

	return result;
};

var parseBlock = (buf) => {
	// identify block type and return corresponding parsed result
	var buf0 = String.fromCharCode(buf[0]), buf1 = String.fromCharCode(buf[1]);

	if (buf0 === 'i') {
		if (buf1 === 'e') {
			return 0;
		}
		return parseInteger(buf);
	} else if (buf0 >= '0' && buf0 <= '9') {
		return parseByteString(buf);
	} else if (buf0 === 'l') {
		if (buf1 === 'e') {
			return [];
		}
		return parseList(buf);
	} else if (buf0 === 'd') {
		if (buf1 === 'e') {
			return {};
		}
		return parseDict(buf);
	} else {
		return -1;
	}
};

// Code for encoding
var detectDataType = (data) => {
	if (data === null || typeof data === 'undefined') {
		return -1;
	}
	if (typeof data === 'string') {
		return 'string';
	}
	if (typeof data === 'boolean') {
		return 'boolean';
	}
	if (typeof data === 'number') {
		return 'number';
	}
	if (Array.isArray(data)) {
		return 'array';
	}
	if (Buffer.isBuffer(data)) {
		return 'buffer';
	}
	if (Object.prototype.toString.call(data) === '[object Object]') {
		return 'object';
	}

	// Other data types
	return -1;
};

var encodeString = (data) => {
	assert(typeof data === 'string');
	return (data.length + ':' + data);
};

var encodeBoolean = (data) => {
	assert(typeof data === 'boolean');
	// convert to number before encoding
	if (data === true) {
		return encodeNumber(1);
	} else {
		return encodeNumber(0);
	}
};

var encodeNumber = (data) => {
	assert(typeof data === 'number' && isNaN(data) === false);
	//TODO number format validation
	return ('i' + data + 'e');
};

var encodeArray = (data) => {
	assert(Array.isArray(data));
	var str = 'l';

	for (let item of data) {
		let encodedItem = encodeData(item);
		if (encodedItem === -1) {
			return -1;
		}
		str += encodedItem;
	}
	str += 'e';

	return str;
};

var encodeObject = (data) => {
	var keys = Object.keys(data).sort();	// assuming keys are all strings
	var str = 'd';

	for (let key of keys) {
		str += encodeString(key);
		str += encodeData(data[key]);
	}
	str += 'e';

	return str;
};

var encodeBuffer = (data) => {
	assert(Buffer.isBuffer(data));
	return encodeString(data.toString('binary'));
};

var encodeData = (data) => {
	var type = detectDataType(data);

	switch (type) {
		case 'string':
			return encodeString(data);
		case 'boolean':
			return encodeBoolean(data);
		case 'number':
			return encodeNumber(data);
		case 'array':
			return encodeArray(data);
		case 'object':
			return encodeObject(data);
		case 'buffer':
			return encodeBuffer(data);
		default:
			return -1;
	}
};